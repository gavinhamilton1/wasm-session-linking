<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scan Pass</title>
    <link rel="stylesheet" href="/static/css/scanner.css">
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.0.2/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.1.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>


</head>
<body>
    <div class="container">
        <h2>Please Scan Pass</h2>
        <div class="camera-section">
            <video id="camera" playsinline autoplay></video>
            <canvas id="canvas"></canvas>
            <div class="scan-region"></div>
            <div id="status" class="status"></div>
            
            <video id="qr-video" autoplay></video>
            <canvas id="frame-canvas"</canvas>
            <div class="frame-container" id="captured-frames"></div>
        </div>

        <div id="resultSection" class="result-section">
            <h3>Scanned QR Code Contents</h3>
            <div id="resultContent" class="result-content"></div>
        </div>

    </div>


    <script type="module">
        import * as Comlink from "https://unpkg.com/comlink/dist/esm/comlink.mjs";
        import * as Base64 from "/apriltag/base64.js";
    
        // Wrap worker inside an async function
        async function initAprilTag() {
            const ApriltagWorker = Comlink.wrap(new Worker("/apriltag/apriltag.js"));
            
            // Initialize AprilTag detector
            window.apriltag = await new ApriltagWorker(Comlink.proxy(() => {
                window.apriltag.set_tag_size(5, 0.5);
            }));
    
            console.log("AprilTag Detector is ready:", window.apriltag);
        }
    
        // Call the async function
        initAprilTag();
    </script>
    
    
    <script>

        let scanning = false;
        const video = document.getElementById("camera");
        const canvas = document.getElementById("canvas");
        const qrVideo = document.getElementById("qr-video");
        const frameCanvas = document.getElementById("frame-canvas");
        const frameContainer = document.getElementById("captured-frames");
        const context = canvas.getContext("2d", { willReadFrequently: true });
        const frameContext = frameCanvas.getContext("2d", { willReadFrequently: true });
        const startButton = document.getElementById("startButton");
        const statusDiv = document.getElementById("status");
        const resultSection = document.getElementById("resultSection");
        const resultContent = document.getElementById("resultContent");
  
        const captureMax = 2;
        let captureCount = 0;
        let aprilTags = [];
        let frameList = [];
        // Initialize WebSocket and other components after DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Start camera after a delay
                await setTimeout(startCamera, 1000);                
            } catch (error) {
                console.error("Initialization error:", error);
            }
        });


        async function detectAprilTagFromImage(imageData) {
            if (!window.apriltag) {
                throw new Error("AprilTag detector is not initialized. Call `init()` first.");
            }
        
            let imageDataPixels = imageData.data;
            let grayscalePixels = new Uint8Array(canvas.width * canvas.height);
        
            for (let i = 0, j = 0; i < imageDataPixels.length; i += 4, j++) {
                let grayscale = Math.round(
                    (imageDataPixels[i] + imageDataPixels[i + 1] + imageDataPixels[i + 2]) / 3
                );
                grayscalePixels[j] = grayscale;
            }
        
            // Run AprilTag detection
            let detections = await window.apriltag.detect(grayscalePixels, canvas.width, canvas.height);
        
            if (detections.length > 0) {
                return detections.map(det => ({
                    id: det.id,
                    center: det.center,
                    corners: det.corners
                }));
            }
        
            return null; // No AprilTag detected
        }

        async function detectAprilTag(canvas) {
            if (!window.apriltag) {
                throw new Error("AprilTag detector is not initialized. Call `init()` first.");
            }
        
            const ctx = canvas.getContext("2d");
            if (!ctx) {
                throw new Error("Failed to get canvas context.");
            }
        
            // Convert canvas image to grayscale
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let imageDataPixels = imageData.data;
            let grayscalePixels = new Uint8Array(canvas.width * canvas.height);
        
            for (let i = 0, j = 0; i < imageDataPixels.length; i += 4, j++) {
                let grayscale = Math.round(
                    (imageDataPixels[i] + imageDataPixels[i + 1] + imageDataPixels[i + 2]) / 3
                );
                grayscalePixels[j] = grayscale;
            }
        
            // Run AprilTag detection
            let detections = await window.apriltag.detect(grayscalePixels, canvas.width, canvas.height);
        
            if (detections.length > 0) {
                return detections.map(det => ({
                    id: det.id,
                    center: det.center,
                    corners: det.corners
                }));
            }
        
            return null; // No AprilTag detected
        }
        
        async function startCamera() {
            try {
                // Hide result section when starting new scan
                resultSection.style.display = "none";
                // Show camera section
                document.querySelector('.camera-section').style.display = "block";
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                scanning = true;
                startScanning();

                await video.play();
        } catch (err) {
                console.error("Camera access denied:", err);
                startButton.style.display = "block";
            }
        }

        function stopCamera() {
            scanning = false;
            const stream = video.srcObject;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            video.srcObject = null;
            // Hide camera section
            document.querySelector('.camera-section').style.display = "none";
        }

        function startScanning() {
            scanning = true;
            resultSection.style.display = "none";
            canvas.width = 1280;
            canvas.height = 720;
            scanQRCode();
        }


        function captureSequence(interval = 100, duration = 1000) {

            frameList = [];
            frameCaptureMax = duration / interval;
            frameCaptureCount = 0;

            let captureInterval = setInterval(() => {
                console.log("Capturing frame:", frameCaptureCount);
                if (frameCaptureCount++ >= frameCaptureMax) {
                    console.log("Captured", frameList.length, "frames.");
                    clearInterval(captureInterval);
                    console.log("Captured", frameList.length, "frames.");
                    frameList.forEach(img => {
                        console.log("Adding frame to container:", img);
                    });
                    processImages(frameList);
                    return;
                } else {
                    frameCanvas.width = video.videoWidth;
                    frameCanvas.height = video.videoHeight;
                    frameContext.drawImage(video, 0, 0, frameCanvas.width, frameCanvas.height);        
                    console.log("Capturing frame:", frameCanvas);
                    frameList.push(frameContext.getImageData(0, 0, frameCanvas.width, frameCanvas.height));
                }
            }, interval);



        }

        async function processImages(frameList) {
            let cnt = 0;
            frameList.forEach(async (imageData) => {
                console.log("Processing image:", cnt++);
                try {
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: "dontInvert",
                    });

                    if (code && code.location) {
                        console.log("Code:", code.data);
                    } else {
                        console.log("No code detected.");
                        
                    }

                    const aprilTagData = await detectAprilTagFromImage(imageData);
                    if (aprilTagData) {
                        console.log("Detected AprilTag(s):", aprilTagData);
                    } else {
                        console.log("No AprilTag detected.");
                    }

                } catch (error) {
                    console.error("Error processing image:", error);
                }

            });
        }


        async function delayedScanQRCodeForStablitiy() {
            captureSequence();
            return;
            if(captureCount > captureMax) return;

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            let imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            
            const code = jsQR(imageData.data, imageData.width, imageData.height, {
                inversionAttempts: "dontInvert",
            });

            console.log("Code:", code);

            if (code && code.location) {
                const angle = correctSkew(imageData, code.location);
                console.log("Angle of rotation (degrees):", angle);
                const rotatedCanvas = rotateImageData(imageData, angle * -1);
                imageData = rotatedCanvas.getContext('2d').getImageData(0, 0, rotatedCanvas.width, rotatedCanvas.height);
                //document.body.appendChild(rotatedCanvas);
                const newcode = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert",
                });

                if (newcode && newcode.location) {
                    console.log("New code:", newcode);
                    const croppedCanvas = cropCanvasToQRCode(rotatedCanvas, newcode.location);
                    const croppedCanvas3rd = cropCanvasToQRCodeCenterThird(rotatedCanvas, newcode.location);
                    document.body.appendChild(croppedCanvas);
                    document.body.appendChild(croppedCanvas3rd);
                    let width = croppedCanvas.width;
                    let height = croppedCanvas.height;

                    console.log("Trying to detect AprilTags...");
                    aprilTagData = await detectAprilTag(croppedCanvas);

                    if (aprilTagData) {
                        aprilTags.push(aprilTagData[0].id);
                        console.log("Detected AprilTag(s):", aprilTagData);
                    } else {
                        console.log("No AprilTag detected.");
                    }
                    
                    console.log("Done detecting AprilTags");

                } else {
                    console.error("Failed to detect QR code in rotated image.");
                }

                qrdata = code.data;
                if (qrdata.length > 0) {
                    try {
                        if (qrdata.includes('{')) {
                            const parsedData = JSON.parse(qrdata);
                            console.log("Parsed data:", parsedData);
                        }
                        
                        document.getElementById("resultSection").style.display = "block";
                        document.getElementById("resultContent").textContent = qrdata 
                        // Extract pattern
                    } catch (error) {
                        console.error('Error:', error);
                    }
                    //document.getElementById("resultSection").style.display = "block";
                    //document.getElementById("resultContent").textContent = code.data;
                }
                if(captureCount++ >= captureMax) {
                    stopCamera();
                    scanning = false;
                    document.getElementById("resultContent").textContent += " " + aprilTags;
                    console.log("Tags found:", aprilTags);
                } else {
                    setTimeout(delayedScanQRCodeForStablitiy, 200);
                }
                scanning = true;
            } else {
                scanning = true;
                console.error("Failed to detect QR code.");
            }
        }



        function scanQRCode() {
            if (!scanning) return;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Throttle scanning to every 250ms
                setTimeout(() => {
                    try {
                        // Draw to canvas for QR detection only
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        let imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        
                        const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });

                        if (code) {
                            setTimeout(delayedScanQRCodeForStablitiy, 500);  //delay for stability
                            scanning = false;
                        }
                    } catch (error) {
                        console.error("Error scanning QR code:", error);
                    }
                    requestAnimationFrame(scanQRCode);
                }, 200);  // Throttle to every 250ms
            } else {
                requestAnimationFrame(scanQRCode);
            }
        }

        async function detectAndCropBox(canvas) {
            // Load the image from the canvas
            const src = cv.imread(canvas);
            // Convert to grayscale
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            
            // Apply Gaussian blur to reduce noise
            cv.GaussianBlur(src, src, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
            
            // Apply adaptive thresholding for better contrast
            cv.adaptiveThreshold(src, src, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
            
            // Apply Canny edge detection with tuned thresholds
            let edges = new cv.Mat();
            cv.Canny(src, edges, 50, 150);
            
            // Perform morphological operations to close gaps
            let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5, 5));
            cv.dilate(edges, edges, kernel, new cv.Point(-1, -1), 1);
    
            // Find contours
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    
            // Create an output image to draw the rectangles
            let output = cv.imread(canvas);
    
            // Iterate through contours to find the largest central rectangle
            let maxArea = 0;
            let bestRect = null;
            let imgCenterX = src.cols / 2;
            let imgCenterY = src.rows / 2;
            
            for (let i = 0; i < contours.size(); i++) {
                let cnt = contours.get(i);
                let rect = cv.boundingRect(cnt);
                let area = rect.width * rect.height;
                let aspectRatio = rect.width / rect.height;
                let rectCenterX = rect.x + rect.width / 2;
                let rectCenterY = rect.y + rect.height / 2;
                let distanceToCenter = Math.sqrt(Math.pow(rectCenterX - imgCenterX, 2) + Math.pow(rectCenterY - imgCenterY, 2));
    
                let color = new cv.Scalar(255, 0, 0, 255); // Blue color for all detected rectangles
                cv.rectangle(output, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), color, 2);
                cv.imshow(canvas, output);
                // Prefer rectangles that are closer to the image center
                if ((area > maxArea && aspectRatio > 0.75 && aspectRatio < 1.3) || (bestRect && distanceToCenter < Math.sqrt(Math.pow(bestRect.x + bestRect.width / 2 - imgCenterX, 2) + Math.pow(bestRect.y + bestRect.height / 2 - imgCenterY, 2)))) {
                    maxArea = area;
                    bestRect = rect;
                }
            }
    
            // Draw the largest central rectangle indicator
            if (bestRect) {
                let color = new cv.Scalar(0, 255, 0, 255); // Green color for final detected box
                cv.rectangle(output, new cv.Point(bestRect.x, bestRect.y), new cv.Point(bestRect.x + bestRect.width, bestRect.y + bestRect.height), color, 2);
            }
    
            console.log("Best rectangle:", bestRect);
    
            // Display the output with the detected largest rectangle
            cv.imshow(canvas, output);
    
            // Crop the image to the detected largest rectangle
            if (bestRect) {
                let cropped = src.roi(bestRect);
                cv.imshow(canvas, cropped);
                cropped.delete();
            }
    
            // Clean up
            src.delete();
            output.delete();
            edges.delete();
            contours.delete();
            hierarchy.delete();
            kernel.delete();
        }

        function cropCanvasToQRCode(canvas, location) {
            const { topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner } = location;
            const qrWidth = topRightCorner.x - topLeftCorner.x;
            const qrHeight = bottomLeftCorner.y - topLeftCorner.y;
            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = qrWidth;  
            croppedCanvas.height = qrHeight;
            const ctx = croppedCanvas.getContext('2d');
            ctx.drawImage(canvas, topLeftCorner.x, topLeftCorner.y, qrWidth, qrHeight, 0, 0, qrWidth, qrHeight);
            return croppedCanvas;
        }
        

        function cropCanvasToQRCodeCenterThird(canvas, location) {
            const { topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner } = location;
    
            // Compute bounding box of QR code
            const minX = Math.min(topLeftCorner.x, topRightCorner.x, bottomRightCorner.x, bottomLeftCorner.x);
            const maxX = Math.max(topLeftCorner.x, topRightCorner.x, bottomRightCorner.x, bottomLeftCorner.x);
            const minY = Math.min(topLeftCorner.y, topRightCorner.y, bottomRightCorner.y, bottomLeftCorner.y);
            const maxY = Math.max(topLeftCorner.y, topRightCorner.y, bottomRightCorner.y, bottomLeftCorner.y);
        
            const qrWidth = maxX - minX;
            const qrHeight = maxY - minY;
        
            // Compute center third dimensions
            const centerX = (minX + qrWidth / 3);
            const centerY = (minY + qrHeight / 3);
            const cropWidth = (qrWidth / 3);
            const cropHeight = (qrHeight / 3);
        
            // Create a new canvas for the cropped image
            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = cropWidth;
            croppedCanvas.height = cropHeight;
            const ctx = croppedCanvas.getContext('2d');
        
            // Draw only the center third of the QR code
            ctx.drawImage(canvas, centerX, centerY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
        
            return croppedCanvas;
        }

        async function preprocessImage(canvas) {
            // Load the image from the canvas
            const src = cv.imread(canvas);
            await detectAndCropBox(canvas)
            // Convert to grayscale
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            // Apply adaptive thresholding
            cv.adaptiveThreshold(src, src, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
            // Denoise the image
            cv.medianBlur(src, src, 3);
            // Resize the image
            let dsize = new cv.Size(src.cols * 2, src.rows * 2);
            cv.resize(src, src, dsize, 0, 0, cv.INTER_LINEAR);
            // Return the processed image
            cv.imshow(canvas, src);
            src.delete();
        }

        async function extractWatermark(canvas) {
            //await preprocessImage(canvas);
            if (typeof cv !== 'undefined' && cv.getBuildInformation) {
                detectAndCropBox(canvas);
            } else {
                setTimeout(detectAndCropBox(canvas), 1000);
            }
            return new Promise((resolve, reject) => {
                Tesseract.recognize(
                    canvas,
                    "eng", // English OCR model
                    null
                ).then(({ data }) => {
                    console.log("OCR data:", data);
                    const text = data.text.replace(/\W/g, "").slice(0, 6);
                    resolve(text);
                }).catch(reject);
            });
        }

        function correctSkew(imageData, location) {
            // Create a canvas to draw the image data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
        
            // Calculate the angle of rotation
            const dx = location.topRightCorner.x - location.topLeftCorner.x;
            const dy = location.topRightCorner.y - location.topLeftCorner.y;
            const angle = Math.atan2(dy, dx); // Angle in radians
            const angleDegrees = angle * (180 / Math.PI);

            console.log("Angle of rotation (degrees):", angleDegrees);
            return angleDegrees;

            // Create a new canvas for the rotated image
            const rotatedCanvas = document.createElement('canvas');
            rotatedCanvas.width = tempCanvas.width;
            rotatedCanvas.height = tempCanvas.height;
            const rotatedCtx = rotatedCanvas.getContext('2d');
        
            // Ensure proper transformation
            rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
            rotatedCtx.rotate(-angle); // Rotate in the opposite direction
            rotatedCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
        
            // Read rotated image into OpenCV
            const src = cv.imread(rotatedCanvas);
            const dst = new cv.Mat();
            const dsize = new cv.Size(300, 300); // Output size
        
            // Adjust points after rotation (Optional: Transform original points)
            const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                location.topLeftCorner.x, location.topLeftCorner.y,
                location.topRightCorner.x, location.topRightCorner.y,
                location.bottomRightCorner.x, location.bottomRightCorner.y,
                location.bottomLeftCorner.x, location.bottomLeftCorner.y
            ]);
        
            const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0,
                dsize.width, 0,
                dsize.width, dsize.height,
                0, dsize.height
            ]);
        
            // Compute perspective transform
            const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
            cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        
            // Display corrected image
            const capturedQRCanvas = document.getElementById('capturedQRCanvas');
            capturedQRCanvas.width = dst.cols;
            capturedQRCanvas.height = dst.rows;
            cv.imshow('capturedQRCanvas', dst);
        
            // Cleanup
            src.delete(); dst.delete(); M.delete(); srcPoints.delete(); dstPoints.delete();
        }
        
        function rotateImageData(imageData, degrees) {
            // Convert degrees to radians
            const radians = degrees * (Math.PI / 180);
        
            // Get original dimensions
            const { width, height } = imageData;
        
            // Compute new canvas size to fit rotated image
            const sin = Math.abs(Math.sin(radians));
            const cos = Math.abs(Math.cos(radians));
            const newWidth = Math.ceil(width * cos + height * sin);
            const newHeight = Math.ceil(width * sin + height * cos);
        
            // Create temporary canvas to hold original image data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0); // Draw ImageData onto temporary canvas
        
            // Create new canvas for the rotated image
            const rotatedCanvas = document.createElement('canvas');
            rotatedCanvas.width = newWidth;
            rotatedCanvas.height = newHeight;
            const ctx = rotatedCanvas.getContext('2d');
        
            // Apply rotation
            ctx.translate(newWidth / 2, newHeight / 2);
            ctx.rotate(radians);
            ctx.drawImage(tempCanvas, -width / 2, -height / 2); // Draw rotated image
            return rotatedCanvas;
        }


    </script>
</body>
</html>