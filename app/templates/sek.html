<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Key Exchange</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        .container {
            display: flex;
            flex-direction: row;  /* Default to row layout */
            align-items: flex-start;
            justify-content: center;
            gap: 40px;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .qr-section {
            text-align: center;
            width: 300px;  /* Fixed width to match camera section */
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 2;
        }
        .camera-section {
            position: relative;
            width: 300px;
            height: 300px;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            z-index: 1;
        }
        #qr-code {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px auto;
            background: white;
        }
        #qr-code img {
            display: block;
            max-width: 100%;
            height: auto;
        }
        #camera {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            opacity: 0;
            object-fit: contain;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            max-width: 90%;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .scan-region {
            border: 2px solid #007bff;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            z-index: 2;
            border-radius: 20px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        }
        #startButton {
            display: none;
        }
        .result-section {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            width: 100%;
            max-width: 500px;
            z-index: 2;
        }
        .result-section h3 {
            margin-top: 0;
            color: #007bff;
        }
        .result-content {
            word-break: break-all;
            font-family: monospace;
            background-color: #fff;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .scan-again-btn {
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .scan-again-btn:hover {
            background-color: #0056b3;
        }

        /* Media query for mobile devices */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;  /* Stack on mobile */
                padding: 10px;
                gap: 20px;
                align-items: flex-start;
                justify-content: center;
                margin: 0 auto;

    
            }
            .qr-section {
                width: 100%;
                max-width: 300px;
            }
            .camera-section {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">

        <div class="qr-section">
            <h2>QR Code (Public Key)</h2>
            <div id="qr-code"></div>
        </div>

        <div class="camera-section">
            <video id="camera" playsinline autoplay></video>
            <canvas id="canvas"></canvas>
            <div class="scan-region"></div>
            <div id="status" class="status"></div>
        </div>


        <div id="resultSection" class="result-section">
            <h3>Scanned QR Code Contents</h3>
            <div id="resultContent" class="result-content"></div>
            <button class="scan-again-btn" onclick="startScanning()">Scan Another Code</button>
        </div>

    </div>
    
    <script>
        let keyPair = null;
        let publicKey = null;
        let scanning = false;
        const video = document.getElementById("camera");
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d", { willReadFrequently: true });
        const startButton = document.getElementById("startButton");
        const statusDiv = document.getElementById("status");
        const resultSection = document.getElementById("resultSection");
        const resultContent = document.getElementById("resultContent");

        async function generateKeyPair() {
            try {
                // Generate ECDH key pair
                keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: "P-256"
                    },
                    true,  // extractable
                    ["deriveKey", "deriveBits"]
                );

                // Export public key to raw format
                const rawPublicKey = await window.crypto.subtle.exportKey(
                    "raw",
                    keyPair.publicKey
                );

                // Convert to base64 for QR code
                publicKey = btoa(String.fromCharCode(...new Uint8Array(rawPublicKey)));
                console.log("Generated public key:", publicKey);
                
                return publicKey;
            } catch (error) {
                console.error("Error generating key pair:", error);
                showStatus("Error generating key pair", true);
                throw error;
            }
        }

        async function deriveSharedSecret(otherPublicKeyBase64) {
            try {
                // Decode the received public key
                const otherPublicKeyBytes = Uint8Array.from(atob(otherPublicKeyBase64), c => c.charCodeAt(0));
                
                // Import the other party's public key
                const otherPublicKey = await window.crypto.subtle.importKey(
                    "raw",
                    otherPublicKeyBytes,
                    {
                        name: "ECDH",
                        namedCurve: "P-256"
                    },
                    true,
                    []
                );

                // Derive shared secret
                const sharedSecret = await window.crypto.subtle.deriveBits(
                    {
                        name: "ECDH",
                        public: otherPublicKey
                    },
                    keyPair.privateKey,
                    256
                );

                // Convert shared secret to base64
                const sharedSecretBase64 = btoa(String.fromCharCode(...new Uint8Array(sharedSecret)));
                console.log("Derived shared secret:", sharedSecretBase64);
                
                showStatus("Shared secret derived successfully!");
                return sharedSecretBase64;
            } catch (error) {
                console.error("Error deriving shared secret:", error);
                showStatus("Error deriving shared secret", true);
                throw error;
            }
        }

        function generateQRCode() {
            if (!publicKey) {
                console.error("Public key is not available for QR code generation.");
                showStatus("Error: Public key not available.", true);
                return;
            }

            const qrData = JSON.stringify({
                type: "public_key",
                key: publicKey,
                timestamp: Date.now()
            });

            console.log("Generating QR code with data:", qrData);

            // Clear any existing QR code first
            const qrElement = document.getElementById("qr-code");
            qrElement.innerHTML = '';
            
            new QRCode(qrElement, {
                text: qrData,
                width: 256,
                height: 256
            });
        }

        function showStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.style.display = "block";
            statusDiv.className = `status ${isError ? 'error' : 'success'}`;
            setTimeout(() => {
                statusDiv.style.display = "none";
            }, 3000);
        }

        async function startCamera() {
            try {
                // Hide result section when starting new scan
                resultSection.style.display = "none";
                // Show camera section
                document.querySelector('.camera-section').style.display = "block";
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: "user",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    scanning = true;
                    scanQRCode();
                });

                await video.play();
                showStatus("Camera started, scanning for QR codes...");
            } catch (err) {
                showStatus("Camera access denied: " + err.message, true);
                console.error("Camera access denied:", err);
                startButton.style.display = "block";
            }
        }

        function stopCamera() {
            scanning = false;
            const stream = video.srcObject;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            video.srcObject = null;
            // Hide camera section
            document.querySelector('.camera-section').style.display = "none";
        }

        function startScanning() {
            scanning = true;
            resultSection.style.display = "none";
            scanQRCode();
            showStatus("Scanning for QR codes...");
        }

        function displayQRContent(content) {
            try {
                if (!content) {
                    throw new Error("QR code content is empty.");
                }

                const data = JSON.parse(content);
                if (data.type === "public_key" && data.key) {
                    resultContent.textContent = "Public key received. Deriving shared secret...";
                    resultSection.style.display = "block";
                    scanning = false;  // Stop scanning but keep camera running
                    
                    // Derive shared secret
                    deriveSharedSecret(data.key).then(sharedSecret => {
                        // Show first 32 characters of shared secret for verification
                        const previewSecret = sharedSecret.substring(0, 32) + "...";
                        resultContent.textContent = `Shared secret derived successfully!\nFirst 32 characters: ${previewSecret}`;
                    }).catch(error => {
                        resultContent.textContent = "Error deriving shared secret: " + error.message;
                    });
                } else {
                    resultContent.textContent = "Invalid QR code format. Expected public key data.";
                    resultSection.style.display = "block";
                }
            } catch (error) {
                console.error("Error processing QR code:", error);
                resultContent.textContent = "Error processing QR code: " + error.message;
                resultSection.style.display = "block";
            }
        }

        function scanQRCode() {
            if (!scanning) return;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Throttle scanning to every 100ms
                setTimeout(() => {
                    // Draw to canvas for QR detection only
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: "dontInvert",
                    });

                    if (code) {
                        console.log("Found QR code:", code.data);
                        showStatus("QR Code detected!");
                        
                        // Just stop scanning but keep video running
                        scanning = false;
                        
                        // Display the QR code content
                        displayQRContent(code.data);
                        
                        // Process the QR code data
                        processQRCode(code.data);
                        return;
                    }

                    requestAnimationFrame(scanQRCode);
                }, 100);  // Throttle to every 100ms
            } else {
                requestAnimationFrame(scanQRCode);
            }
        }

        function drawQRCodeOutline(location) {
            context.beginPath();
            context.moveTo(location.topLeftCorner.x, location.topLeftCorner.y);
            context.lineTo(location.topRightCorner.x, location.topRightCorner.y);
            context.lineTo(location.bottomRightCorner.x, location.bottomRightCorner.y);
            context.lineTo(location.bottomLeftCorner.x, location.bottomLeftCorner.y);
            context.lineTo(location.topLeftCorner.x, location.topLeftCorner.y);
            context.strokeStyle = "#FF3B58";
            context.lineWidth = 4;
            context.stroke();
        }

        function processQRCode(data) {
            try {
                const parsedData = JSON.parse(data);
                console.log("Processing QR code data:", parsedData);
                // Only log the processing - remove the fetch call since we're handling everything client-side
                showStatus('QR code processed successfully');
            } catch (error) {
                console.error('Error:', error);
                showStatus('Error processing QR code', true);
            }
        }

        // Initialize key pair and QR code
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await generateKeyPair();
                generateQRCode();
                startCamera();
                //setTimeout(startCamera, 1000);
            } catch (error) {
                console.error("Initialization error:", error);
                showStatus("Initialization error: " + error.message, true);
            }
        });


        // Update visibility handler to not stop camera
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                scanning = false;  // Only stop scanning
            } else if (!resultSection.style.display || resultSection.style.display === "none") {
                startScanning();  // Resume scanning
            }
        });
    </script>
</body>
</html>
