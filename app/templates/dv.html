<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' 'unsafe-eval';
                   style-src 'self' 'unsafe-inline';
                   img-src 'self' data: https:;
                   connect-src 'self';
                   font-src 'self';
                   object-src 'none';
                   base-uri 'self';
                   form-action 'self';">
    <title>WASM Session Linking Demo</title>
    <link rel="stylesheet" href="/static/css/scanner.css">

    <script>
        let globalUuid = null;
        let socketState = 'OPEN';
    </script>

    <script type="module">
        import init, { verify_domain_and_display_qr } from "./pkg/wasm_domain_verification.js";

        // Define the function and attach it to the window object
        window.store_uuid_in_js = function(uuid) {
            globalUuid = uuid;
            console.log("UUID stored in global variable:", globalUuid);
        };


        async function run() {
            await init();
            try {
                await verify_domain_and_display_qr();
                setupWebSocket();
            } catch (e) {
                console.error("WASM execution failed:", e);
            }
        }
        window.onload = run;
    </script>

    <script>
        window.addEventListener('error', function(event) {
            console.error(event.message);
        });

        function processMessage(message) {
            try {
                let data = typeof message === 'object' ? message : JSON.parse(message);
                if (data.status === 'SESSION_OK') {
                    console.log("Session is OK");
                    document.getElementById('qr-container').remove();
                    document.getElementById('status-container').innerHTML = "Session is OK: " + data.aprilTags;
                
                    // Close the WebSocket connection
                    if (window.ws) {
                        console.log("Closing WebSocket connection");
                        //socketState = 'CLOSED';
                        //window.ws.close(1000, "Session completed"); // 1000 is the normal closure status code
                    }
                }
            } catch (error) {
                console.log("Received message:", message);
            }
        }

        // Add WebSocket state monitoring
        function updateWebSocketState() {
            if (window.ws) { // ✅ Now using global WebSocket reference
                const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
                console.log("WebSocket state: ", states[window.ws.readyState]);
            }
        }
        
        
        // Add network status monitoring
        window.addEventListener('online', () => console.log("Network: Online"));
        window.addEventListener('offline', () => console.log("Network: Offline"));
        
        // WebSocket handling with debug info
        function setupWebSocket() {
            if (!globalUuid) {
                console.error("Global UUID is not set. Cannot establish WebSocket connection.");
                setTimeout(() => {
                    setupWebSocket();
                }, 1000);
                return;
            }
        
            const sessionId = globalUuid;
            const uuid = crypto.randomUUID();
            console.log("Setting up WebSocket with session ID:", sessionId);
        
            // Determine secure WebSocket (wss) if page is HTTPS
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${sessionId}/${uuid}`;
        
            console.log(`Connecting to WebSocket at: ${wsUrl}`);
        
            // 🔹 Set `window.ws` before using it
            window.ws = new WebSocket(wsUrl);
        
            // Connection opened
            window.ws.onopen = () => {
                console.log('WebSocket connection established');
                updateWebSocketState();
            };
        
window.ws.onmessage = (event) => {
    const message = event.data.trim();

    if (message.startsWith("Connected to session")) {
        console.log(`✅ WebSocket Connected: ${message}`);
        return;
    }

    try {
        console.log(`📩 Received raw WebSocket message:`, message);

        let data;
        if (typeof message === "object") {
            data = message;
        } else {
            data = JSON.parse(message);
        }

        if (data && data.type === "signature") {
            if (data.pen_up === "true") {
                console.log("Pen Up: True - resetting path");
                resetSignaturePath();
            } else if (typeof data.x === "number" && typeof data.y === "number") {
                console.log("Drawing coordinates:", data.x, data.y);
                drawPoint(data.x, data.y);
                drawSmoothStroke(data.x, data.y);
            }
        } else if (data.type === "reset") {
            console.log("🧹 Resetting Canvas...");
            resetCanvas();
        } else {
            processMessage(data);
        }
    } catch (error) {
        console.error(`❌ JSON Parsing Error:`, message, `Error:`, error);
    }
};



        
            // Connection closed
            window.ws.onclose = (event) => {
                console.log('WebSocket connection closed', event.code, event.reason);
                updateWebSocketState();
        
                // Try to reconnect after a delay
                if (socketState !== 'CLOSED') {
                    setTimeout(() => {
                        console.log('Attempting to reconnect WebSocket...');
                        setupWebSocket();
                    }, 5000);
                }
            };
        
            // Connection error
            window.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateWebSocketState();
            };
        }
        
// ✅ Declare points globally (so it's available in all calls)
let points = [];

function drawPoint(x, y) {
    console.log("Drawing points: " + x + " " + y);
    const canvas = document.getElementById("displayCanvas");
    const ctx = canvas.getContext("2d");
    
    ctx.beginPath();
    ctx.arc(x, y, 1, 0, 2 * Math.PI);
    ctx.fillStyle = "#000";
    ctx.fill();
}


function drawSmoothStroke(x, y) {
    const canvas = document.getElementById("displayCanvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
        console.error("❌ Canvas context is not available.");
        return;
    }

    // ✅ Ensure points array is initialized
    if (!Array.isArray(points)) {
        points = [];
    }

    // ✅ Add the new point
    points.push({ x, y });

    // ✅ Limit stored points to avoid memory bloat
    if (points.length > 500) { // Increased limit to store more points
        points.shift();
    }

    // ✅ Draw the stroke (without clearing previous strokes)
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y); // Start from first point

    for (let i = 1; i < points.length - 1; i++) {
        let midX = (points[i].x + points[i + 1].x) / 2;
        let midY = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, midX, midY);
    }

    ctx.strokeStyle = "#000"; // Black stroke
    ctx.lineWidth = 2;
    ctx.stroke();
}

        
        // Reset points when a new drawing session starts
        function resetSignaturePath() {
            points = [];
        }

        function resetCanvas() {
            resetSignaturePath();
            const canvas = document.getElementById("displayCanvas");
            if (!canvas) {
                console.error("❌ Canvas not found!");
                return;
            } else {
                canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function drawSignature(x, y) {
            const canvas = document.getElementById("displayCanvas");
            if (!canvas) {
                console.error("❌ Canvas not found!");
                return;
            }
        
            const ctx = canvas.getContext("2d");
            if (!ctx) {
                console.error("❌ Unable to get 2D drawing context!");
                return;
            }
        
            // Set drawing properties (to match mobile strokes)
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#000";
            ctx.lineCap = "round";
        
            // Draw point
            ctx.lineTo(x, y);
            ctx.stroke();
        
            console.log(`🖊️ Drawing at (${x}, ${y})`);
        }
        
    </script>
</head>
<body>
    <h1>WASM Secure Session Linking</h1>
    <h3>Visit <span id="mobile-link">stronghold-test.onrender.com/m</span> from your mobile phone to start</h3>
    <div id="qr-container">
    </div>
    <div id="status-container"></div>

    <!--div class="feature-container">
            <h2>Security Features</h2>
            <ul>
                <li>
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 12l2 2 4-4" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="12" cy="12" r="10" stroke="#27ae60" stroke-width="2" fill="none"/>
                    </svg>
                    Hardened ephemeral WASM binary with pinned cert
                </li>
                <li>
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 12l2 2 4-4" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="12" cy="12" r="10" stroke="#27ae60" stroke-width="2" fill="none"/>
                    </svg>
                    All-way E2E forward secrecy session encryption
                </li>
                <li>
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 12l2 2 4-4" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="12" cy="12" r="10" stroke="#27ae60" stroke-width="2" fill="none"/>
                    </svg>
                    Dynamic animated QR codes
                </li>
                <li>
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 12l2 2 4-4" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="12" cy="12" r="10" stroke="#27ae60" stroke-width="2" fill="none"/>
                    </svg>
                    WASM & Server domain verification exchange
                </li>
                <li>
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 12l2 2 4-4" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="12" cy="12" r="10" stroke="#27ae60" stroke-width="2" fill="none"/>
                    </svg>
                    HTTPS and WSS Communications
                </li>
                <li>
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 12l2 2 4-4" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="12" cy="12" r="10" stroke="#27ae60" stroke-width="2" fill="none"/>
                    </svg>
                    Web tech for browser and mobile
                </li>
            </ul>
        </div-->
        <h2>ClientA - View Signature</h2>
        <canvas id="displayCanvas" width="300" height="200" style="border:1px solid black;"></canvas>
    
</body>

<script>



    const config = {
        iceServers: [
            { urls: "stun:stun.l.google.com:19302" },  // STUN
            { 
              urls: "turn:TURN_SERVER_IP",  // Replace with a real TURN server
              username: "user",
              credential: "password"
            }
        ]
    };
    const peerConnection = new RTCPeerConnection(config);
    

    async function detectWebRTCBlocking() {
        return new Promise((resolve) => {
            if (typeof RTCPeerConnection === "undefined") {
                console.log("WebRTC is not supported in this browser.");
                resolve({ webrtc_supported: false, udp_blocked: true });
                return;
            }
    
            let rtc = new RTCPeerConnection({
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" }, // Public Google STUN server
                ]
            });
    
            let iceCheckTimeout = setTimeout(() => {
                console.log("⚠️ No ICE candidates received - WebRTC may be blocked!");
                resolve({ webrtc_supported: true, udp_blocked: true });
                rtc.close();
            }, 5000); // Timeout if no ICE candidates are received
    
            rtc.onicecandidate = (event) => {
                if (event.candidate) {
                    let candidate = event.candidate.candidate;
                    console.log("✅ ICE Candidate:", candidate);
    
                    if (candidate.includes("udp")) {
                        console.log("✅ WebRTC UDP traffic is allowed.");
                        clearTimeout(iceCheckTimeout);
                        resolve({ webrtc_supported: true, udp_blocked: false });
                        rtc.close();
                    } else if (candidate.includes("tcp")) {
                        console.log("⚠️ WebRTC is using TCP, UDP might be blocked.");
                        clearTimeout(iceCheckTimeout);
                        resolve({ webrtc_supported: true, udp_blocked: true });
                        rtc.close();
                    }
                }
            };
    
            rtc.createDataChannel("test"); // Create a dummy data channel to trigger ICE candidate gathering
            rtc.createOffer()
                .then((offer) => rtc.setLocalDescription(offer))
                .catch((error) => {
                    console.error("Error creating WebRTC offer:", error);
                    resolve({ webrtc_supported: true, udp_blocked: true });
                });
        });
    }
    
    // ✅ Run the WebRTC Firewall Detection
    detectWebRTCBlocking().then(result => {
        console.log("WebRTC Supported:", result.webrtc_supported);
        console.log("UDP Blocked:", result.udp_blocked);
    });




    function setupDisplayCanvas() {
        const canvas = document.createElement("canvas");
        canvas.width = 300;
        canvas.height = 200;
        canvas.style.border = "1px solid black";
        document.body.appendChild(canvas);
    
        const ctx = canvas.getContext("2d");
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000";
        ctx.beginPath();
    

    }













</script>
</html>
